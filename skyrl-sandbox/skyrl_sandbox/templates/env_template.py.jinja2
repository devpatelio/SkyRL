"""{{ spec.env_name.capitalize() }} environment for SkyRL-Gym."""

import re
{% if spec.parsing.method == "json_path" %}
import json
from jsonpath_ng import parse as jsonpath_parse
{% endif %}
from typing import Dict, Any, List, Tuple
from skyrl_gym.envs.base_text_env import BaseTextEnv, BaseTextEnvStepOutput


class {{ spec.env_name.capitalize() }}Env(BaseTextEnv):
    """
    {{ spec.description or "Environment generated by SkyRL Sandbox." }}
    
    Environment type: {{ spec.env_type }}
    {% if spec.env_type == "multi_turn" %}Max turns: {{ spec.max_turns }}{% endif %}
    Parsing method: {{ spec.parsing.method }}
    Reward method: {{ spec.reward.method }}
    """
    
    def __init__(self, ground_truth: Any, {% if spec.env_type == "multi_turn" %}max_turns: int = {{ spec.max_turns }}, {% endif %}**kwargs):
        super().__init__(**kwargs)
        self.ground_truth = ground_truth
        {% if spec.env_type == "multi_turn" %}
        self.max_turns = max_turns
        self.turns = 0
        {% endif %}
    
    def _parse_action(self, action: str) -> Any:
        """Extract answer from model output."""
        {% if spec.parsing.method == "regex" %}
        match = re.search(r"{{ spec.parsing.pattern }}", action)
        return match.group(1) if match else None
        {% elif spec.parsing.method == "json_path" %}
        try:
            data = json.loads(action)
            jsonpath_expr = jsonpath_parse("{{ spec.parsing.json_path }}")
            matches = jsonpath_expr.find(data)
            return matches[0].value if matches else None
        except (json.JSONDecodeError, Exception):
            return None
        {% endif %}
    
    def _calculate_reward(self, answer: Any, found_answer: bool) -> float:
        """Calculate reward based on the answer."""
        {% if spec.reward.method == "exact_match" %}
        if answer is not None and str(answer).strip() == str(self.ground_truth).strip():
            return {{ spec.reward.correct_reward }}
        {% if spec.reward.partial_reward is not none %}
        elif found_answer:
            return {{ spec.reward.partial_reward }}
        {% endif %}
        else:
            return {{ spec.reward.incorrect_reward }}
        {% elif spec.reward.method == "regex_match" %}
        if answer is not None and re.match(str(self.ground_truth), str(answer)):
            return {{ spec.reward.correct_reward }}
        {% if spec.reward.partial_reward is not none %}
        elif found_answer:
            return {{ spec.reward.partial_reward }}
        {% endif %}
        else:
            return {{ spec.reward.incorrect_reward }}
        {% elif spec.reward.method == "numeric_tolerance" %}
        try:
            if answer is not None:
                answer_num = float(answer)
                ground_truth_num = float(self.ground_truth)
                if abs(answer_num - ground_truth_num) <= {{ spec.reward.tolerance or 0.01 }}:
                    return {{ spec.reward.correct_reward }}
        except (ValueError, TypeError):
            pass
        {% if spec.reward.partial_reward is not none %}
        if found_answer:
            return {{ spec.reward.partial_reward }}
        {% endif %}
        return {{ spec.reward.incorrect_reward }}
        {% endif %}
    
    def step(self, action: str) -> BaseTextEnvStepOutput:
        """Execute one step in the environment."""
        {% if spec.env_type == "multi_turn" %}
        self.turns += 1
        {% endif %}
        
        answer = self._parse_action(action)
        found_answer = answer is not None
        reward = self._calculate_reward(answer, found_answer)
        is_correct = reward == {{ spec.reward.correct_reward }}
        
        {% if spec.env_type == "single_turn" %}
        # Single-turn environment always ends after one step
        return BaseTextEnvStepOutput(
            observations=[],
            reward=reward,
            done=True,
            metadata={"parsed_answer": answer}
        )
        {% elif spec.env_type == "multi_turn" %}
        # Determine if episode is done
        {% if spec.done_condition == "always_single_step" %}
        done = True
        {% elif spec.done_condition == "max_turns_only" %}
        done = self.turns >= self.max_turns
        {% elif spec.done_condition == "correct_or_max_turns" %}
        done = self.turns >= self.max_turns or is_correct
        {% endif %}
        
        if done:
            return BaseTextEnvStepOutput(
                observations=[],
                reward=reward,
                done=True,
                metadata={"parsed_answer": answer, "turns": self.turns}
            )
        
        # Provide feedback for another attempt
        if found_answer and not is_correct:
            feedback = """{{ spec.feedback.on_incorrect }}""".format(answer=answer)
        else:
            feedback = """{{ spec.feedback.on_format_error }}"""
        
        return BaseTextEnvStepOutput(
            observations=[{"role": "user", "content": feedback}],
            reward=0.0,  # No reward on intermediate turns
            done=False,
            metadata={"parsed_answer": answer, "turns": self.turns}
        )
        {% endif %}

